Лабораторна робота: “Програмування елементів ОС та використання механізмів ОС”.
 
 
Завдання.
 
Розв’язки задач повинні бути запрограмовані мовою C/C++ та містити повний комплект модулів (файлів, проектів тощо), а також тестових файлів – за потреби, для демонстрації всіх запитуваних можливостей.
 
 
Спільна умова для варіантів 1 – 21.
 
Програми (процеси, потоки – згідно варіанту задачі), що реалізують функції f(x) і g(x), займаються тільки обчисленням значення над вхідним аргументом, вони не обробляють ніяких інших запитів (у тому числі – про завершення обчислень) і не взаємодіють з іншими процесами та потоками ні в який інший спосіб, окрім викликів обчислень f(x) і g(x) (тобто запуску функції на обчислення) та повернення результату (коли обчислення результату завершено) – див. малюнок нижче.
 

 
Зауважити, що функції f та g – можуть бути частково визначені (тобто «зациклюватись» і ніколи не повертати результат). Потрібно коректно опрацювати таку ситуацію і запитати користувача: «продовжити обчислення, припинити або продовжити, не запитуючи більше» наприклад, кожні 10 секунд.
 
Увага! Скористатись правилами булевих обчислень:
x && false == false && x == false
та
x || true == true || x == true
де х Î {true, false}.
А також врахувати, що 0 * x == x * 0 == 0 для довільного числа x.
 
 
 
Варіанти.
 
1.      Взаємодія потоків. Паралелізм. Обчислити f(x) * g(x), використовуючи 2 допоміжні потоки (threads): один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію *.
 
2.      Взаємодія потоків. Паралелізм. Обчислити f(x) && g(x), використовуючи 2 допоміжні потоки (threads): один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію &&.
 
3.      Взаємодія потоків. Паралелізм. Обчислити f(x) || g(x), використовуючи 2 допоміжні потоки (threads): один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію ||.
 
4.      Взаємодія процесів. Паралелізм. Управління стандартним вводом-виводом. Обчислити f(x) * g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію *. Не використовувати обмін повідомленнями між процесами та порти. Процеси f та g читають дані з stdin, а результати пишуть в stdout, але не безпосередньо – вводом і виводом керує основна програма, вона посилає на вхід f і g дані та отримує від них результати. Забороняється використовувати допоміжні файли для обміну інформацією між процесами.
 
5.      Взаємодія процесів. Паралелізм. Управління стандартним вводом-виводом. Обчислити f(x) && g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію &&. Не використовувати обмін повідомленнями між процесами та порти. Процеси f та g читають дані з stdin, а результати пишуть в stdout, але не безпосередньо – вводом і виводом керує основна програма, вона посилає на вхід f і g дані та отримує від них результати. Забороняється використовувати допоміжні файли для обміну інформацією між процесами.
 
6.      Взаємодія процесів. Паралелізм. Управління стандартним вводом-виводом. Обчислити f(x) || g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію ||. Не використовувати обмін повідомленнями між процесами та порти. Процеси f та g читають дані з stdin, а результати пишуть в stdout, але не безпосередньо – вводом і виводом керує основна програма, вона посилає на вхід f і g дані та отримує від них результати. Забороняється використовувати допоміжні файли для обміну інформацією між процесами.
 
7.      Взаємодія процесів. Паралелізм. Обмін повідомленнями. Обчислити f(x) * g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію *. Використати обмін повідомленнями між процесами (Messages). Реалізувати варіант блокуючих операцій обміну повідомленнями, тобто з очікуванням обробки повідомлення і відповіді на повідомлення (і “зависанням” процесу на цей час). Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
8.      Взаємодія процесів. Паралелізм. Обмін повідомленнями. Обчислити f(x) && g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію &&. Використати обмін повідомленнями між процесами (Messages). Реалізувати варіант блокуючих операцій обміну повідомленнями, тобто з очікуванням обробки повідомлення і відповіді на повідомлення (і “зависанням” процесу на цей час). Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
9.      Взаємодія процесів. Паралелізм. Обмін повідомленнями. Обчислити f(x) || g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію ||. Використати обмін повідомленнями між процесами (Messages). Реалізувати варіант блокуючих операцій обміну повідомленнями, тобто з очікуванням обробки повідомлення і відповіді на повідомлення (і “зависанням” процесу на цей час). Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
10.  Взаємодія процесів. Паралелізм. Обмін повідомленнями. Обчислити f(x) * g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію *. Використати обмін повідомленнями між процесами (Messages). Реалізувати варіант неблокуючих операцій обміну повідомленнями, тобто з “перериванням” обчислень і їх продовженням (відновленням) після отримання повідомлень з результатами ініційованих допоміжних обчислень. Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
11.  Взаємодія процесів. Паралелізм. Обмін повідомленнями. Обчислити f(x) && g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію &&. Використати обмін повідомленнями між процесами (Messages). Реалізувати варіант неблокуючих операцій обміну повідомленнями, тобто з “перериванням” обчислень і їх продовженням (відновленням) після отримання повідомлень з результатами ініційованих допоміжних обчислень.Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
12.  Взаємодія процесів. Паралелізм. Обмін повідомленнями. Обчислити f(x) || g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію ||. Використати обмін повідомленнями між процесами (Messages). Реалізувати варіант неблокуючих операцій обміну повідомленнями, тобто з “перериванням” обчислень і їх продовженням (відновленням) після отримання повідомлень з результатами ініційованих допоміжних обчислень. Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
13.  Взаємодія процесів. Паралелізм. Обмін повідомленнями через порт. Обчислити f(x) * g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію *. Використати обмін повідомленнями між процесами через порт (Socket). Реалізувати варіант блокуючих операцій обміну повідомленнями, тобто з очікуванням обробки повідомлення і відповіді на повідомлення (і “зависанням” процесу на цей час). Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
14.  Взаємодія процесів. Паралелізм. Обмін повідомленнями через порт. Обчислити f(x) && g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію &&. Використати обмін повідомленнями між процесами через порт (Socket). Реалізувати варіант блокуючих операцій обміну повідомленнями, тобто з очікуванням обробки повідомлення і відповіді на повідомлення (і “зависанням” процесу на цей час). Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
15.  Взаємодія процесів. Паралелізм. Обмін повідомленнями через порт. Обчислити f(x) || g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію ||. Використати обмін повідомленнями між процесами через порт (Socket). Реалізувати варіант блокуючих операцій обміну повідомленнями, тобто з очікуванням обробки повідомлення і відповіді на повідомлення (і “зависанням” процесу на цей час). Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
16.  Взаємодія процесів. Паралелізм. Обмін повідомленнями через порт. Обчислити f(x) * g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію *. Використати обмін повідомленнями між процесами через порт (Socket). Реалізувати варіант неблокуючих операцій обміну повідомленнями, тобто з “перериванням” обчислень і їх продовженням (відновленням) після отримання повідомлень з результатами ініційованих допоміжних обчислень. Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
17.  Взаємодія процесів. Паралелізм. Обмін повідомленнями через порт. Обчислити f(x) && g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію &&. Використати обмін повідомленнями між процесами через порт (Socket). Реалізувати варіант неблокуючих операцій обміну повідомленнями, тобто з “перериванням” обчислень і їх продовженням (відновленням) після отримання повідомлень з результатами ініційованих допоміжних обчислень. Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
18.  Взаємодія процесів. Паралелізм. Обмін повідомленнями через порт. Обчислити f(x) || g(x), використовуючи 2 допоміжні процеси: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію ||. Використати обмін повідомленнями між процесами через порт (Socket). Реалізувати варіант неблокуючих операцій обміну повідомленнями, тобто з “перериванням” обчислень і їх продовженням (відновленням) після отримання повідомлень з результатами ініційованих допоміжних обчислень. Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати між собою.
 
19.  Взаємодія потоків. Паралелізм. Спільна пам’ять. Обчислити f(x) * g(x), використовуючи 2 допоміжні потоки: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію *. Використати спільну пам’ять (shared memory) для взаємодії. Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати ні між собою.
 
20.  Взаємодія потоків. Паралелізм. Спільна пам’ять. Обчислити f(x) && g(x), використовуючи 2 допоміжні потоки: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію &&. Використати спільну пам’ять (shared memory) для взаємодії. Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати ні між собою.
 
21.  Взаємодія потоків. Паралелізм. Спільна пам’ять. Обчислити f(x) || g(x), використовуючи 2 допоміжні потоки: один обчислює f(x), а інший – g(x). Основна програма виконує ввод-вивід та операцію ||. Використати спільну пам’ять (shared memory) для взаємодії. Функції f(x) та g(x) “нічого не знають друг про друга” і не можуть комунікувати ні між собою.
 
 
 
 
22.  Потоки. Паралелізм. Помножити матриці A[n x m] та B[m x k]. Для обчислення створити (динамічно, автоматично) n*k [однотипних] потоків для обчислень (множення векторів). Передбачити введення матриці з клавіатури або авто-генерування та виведення результату обчислень “по ходу обчислень”. Продемонструвати непослідовність обчислень елементів матриці-добутку.
 
23.  Взаємодія потоків, критичний сегмент. Промоделювати паралельну роботу двох потоків (threads) з загальною коміркою пам’яті: а) з використанням критичного сегменту, б) без використання критичного сегменту. Продемонструвати різницю. (Наприклад, збільшувати значення спільної комірки на 1 1000 разів в кожному потоці.)
 
24.  Взаємодія процесів, критичний сегмент. Промоделювати паралельну роботу двох процесів з загальною коміркою пам’яті, що належить третьому процесу, який надає 2 функції – прочитати і записати цю комірку. Наприклад, збільшувати значення спільної комірки на 1 1000 разів в кожному процесі. Побудувати та реалізувати “правильну” (в результаті значення комірки є 2000) і “неправильну” (значення може бути менше 2000) моделі взаємодії.
 
25.  Взаємодія процесів. Монітор стану процесу. Промоделювати взаємодію двох процесів на наступному прикладі: один процес виводить повідомлення (в свій ListBox або в Memo) про запуск і зупинку (закриття вікна) другого процесу, а також його стан на початку роботи і при виході з першого (у вигляді повідомлення Message на модальному вікні першого процесу). В якості другого процесу треба взяти а) процес з фіксованим іменем запускного файлу процесу (File Name [.exe]), б) процес з фіксованим іменем вікна (Window Caption). Другий процес нічого не знає про перший і не робить ніяких специфічних дій щодо повідомлення про свій стан.
 
26.  Взаємодія процесів. Монітор стану процесу. Промоделювати взаємодію двох процесів на наступному прикладі: один процес виводить повідомлення (в свій ListBox або в Memo) про стан другого процесу (запущений, закритий, не відповідає) при натисканні кнопки опитування або кожні N секунд. В якості другого процесу треба взяти а) процес з фіксованим іменем запускного файлу процесу (File Name [.exe]), б) процес з фіксованим іменем вікна (Window Caption). Другий процес нічого не знає про перший і не робить ніяких специфічних дій щодо повідомлення про свій стан.
 
27.  Семафор. Запрограмувати Resource Server – сервер деякого ресурсу, який “видає” вільні ресурси процесам (реалізує операції P і V), що їх запитують і проводить індикацію стану ресурсу, а також програму – Client, яка запитує ресурси і відображає успішність операцій з ресурсами (за допомогою неї можна запитати і віддати ресурс). Програма Client повинна виводити інформацію про стан з великою деталізацією і бути запущеною кілька раз. Реалізувати моделювання управління а) іменованими ресурсами (наприклад, файли файлової системи), б) ресурсами без імен або з неважливими іменами (оперативна пам’ять, процесорний час).
 
28.  Тупики. Виявлення тупиків. Реалізувати Resource Server (див. умову 5 варіанту), який управляє кількома ресурсами та Client, який може запитувати будь-який з ресурсів (Client повинен бути множинним, тобто запущений кілька разів). Resource Server повинен виявляти тупикові ситуації (перехресний запит ресурсів клієнтами) та повідомляти про них (наприклад, через Message Box або в деякому журналі подій ListBox).
 
29.  Тупики. Виключення типиків. Те ж саме, що і в попередньому варіанті, але Resource Server повинен не допускати виникнення тупиків і впливати на ситуацію, якщо виникає типик. Промоделювати на прикладі СУБД.
 
 
 
